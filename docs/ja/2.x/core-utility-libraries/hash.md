# Hash

`class` **Hash**

::: info Added in version 2.2
:::

配列マネジメントはとても強力かつ便利なツールであり、適切に使いさえすれば、
よりスマートでより最適化されたコードを書くことができるようになるものです。
CakePHP ではとても便利なユーティリティ群を Hash クラスの中に
static で用意しており、まさにこれをするのに使えます。

CakePHP の Hash クラスは Inflector クラスと同様で、どのモデルや
コントローラからでも呼ぶことができます。 例: `Hash::combine()`。

## Hash パス構文

下記のパス構文は `Hash` が持つすべてのメソッドで使われるものです。
ただし、すべてのパス構文が、すべてのメソッドで使用可能であるとは限りません。
パスの式はいくつものトークンで構成されます。トークンは、配列データの移動に使う『式』と、
要素を絞り込む『マッチャー』の２つのグループに大きく分けられます。
マッチャーは要素の式に対して適用することができます。

### 式の種類

| 式    | 説明                                     |
|-------|------------------------------------------|
| `{n}` | 数値キーを意味する。どんな文字列キーでも 
         数値型のキーでも一致する。                |
| `{s}` | 文字列キーを意味する。数値文字列を含め、 
         どんな文字列でも一致する。                |
| `{*}` | 型に関係なく任意の値を表す。             |
| `Foo` | 完全に同じ値だった場合のみ一致する。     |

要素の式はいずれも、すべてのメソッドで使うことができます。特定のメソッドでは、
要素の式に加え、 属性で絞り込むこともできます。該当するメソッドは、
`extract()`,　`combine()`, `format()`, `check()`, `map()`, `reduce()`,
`apply()`, `sort()`, `insert()`, `remove()` と `nest()` です。

### 属性の絞り込み種別

| マッチャー     | 説明                                     |
|----------------|------------------------------------------|
| `[id]`         | 記述されたキーと一致する要素に絞り込む。 |
| `[id=2]`       | id が 2 となっている要素に絞り込む。     |
| `[id!=2]`      | id が 2 ではない要素に絞り込む。         |
| `[id>2]`       | id が 2 より大きい要素に絞り込む。       |
| `[id>=2]`      | id が 2 以上の要素に絞り込む。           |
| `[id<2]`       | id が 2 より小さい要素に絞り込む。       |
| `[id<=2]`      | id が 2 以下の要素に絞り込む。           |
| `[text=/.../]` | 正規表現 `...` と合致する値を持っている  
                  要素に絞り込む。                          |

::: info Changed in version 2.5
`insert()` と `remove()` にマッチャーのサポートが追加されました。`get()` は `extract()` のシンプル版で、直接的に指定するパス式のみがサポートされます。`{n}` や `{s}` 、マッチャーを使ったパスはサポートされません。配列から１つの値だけを取り出したい場合に `get()` を使ってください。`Hash::extract()` は  にあるすべての式とマッチャーをサポートします。extract を使うことで、配列から好きなパスに沿ったデータを手早く取り出すことができます。もはやデータ構造をループする必要はありません。その代わりに欲しい要素を絞り込むパス式を使うのです:$data を `$path` の定義に従って配列の中に挿入します。　:`{n}` や `{s}` を使ったパスを使うことで、複数のポイントにデータを挿入することができます:$path に合致するすべての要素を配列から削除します。 :`{n}` や `{s}` を使うことで、複数の値を一度に削除することができます。$keyPath のパスをキー、$valuePath （省略可） のパスを値として使って連想配列を作ります。$valuePath が省略された場合や、$valuePath に合致するものが無かった場合は、値は null で初期化されます。$groupPath が指定された場合は、そのパスにしたがって生成したものをグルーピングします:$keyPath と $valuePath の両方とも、配列を指定することができます。その場合は、配列の１要素目はフォーマット文字列とみなされ、２要素目以降のパスで取得された値のために使われます:配列から取り出し、フォーマット文字列でフォーマットされた文字列の配列を返します:一方のハッシュや配列の中に、もう一方のキーと値が厳密に見てすべて存在しているかを判定します:配列の中に特定のパスがセットされているかをチェックします:配列から空の要素（ただし '0' 以外）を取り除きます。また、カスタム引数 $callback を指定することで配列の要素を抽出することができます。コールバック関数が `false` を返した場合、その要素は配列から取り除かれます:多次元配列を１次元配列へと平坦化します:`Hash::flatten()`:: によって前もって平坦化された配列を再構築します:この関数は PHP の `array_merge` と `array_merge_recursive` の両方の機能を持っていると考えることができます。この２つの関数との違いは、一方の配列キーがもう一方に含まれていた場合には (`array_merge` と違って) 再帰的に動きますが、含まれていなかった場合には (`array_merge_recursive` と違って) 再帰的には動きません。配列内のすべての値が数値であるかをチェックします:配列の次元数を数えます。このメソッドは配列の１つ目の要素だけを見て次元を判定します:`~Hash::dimensions()` に似ていますが、このメソッドは配列内にあるもっとも大きな次元数を返します:$path で抽出し、各要素に $function を割り当て（map）ることで新たな配列を作ります。このメソッドでは式とマッチャーの両方を使うことができます。$path で抽出し、抽出結果を $function で縮小（reduce）することでを単一の値を作ります。このメソッドでは式とマッチャーの両方を使うことができます。 によって、どの次元のどの値によってでもソートすることができます。このメソッドでは式のみがサポートされます:`$dir` には `asc` もしくは `desc` を指定することができます。`$type` には次のいずれかを指定することができます。２つの配列の差分を計算します:この関数は２つの配列をマージし、差分は、その結果の配列の下部に push します。::配列を正規化します。 `$assoc` が true なら、連想配列へと正規化された配列が返ります。値を持つ数値キーは null を持つ文字列キーへと変換されます。配列を正規化すると、 `Hash::merge()` で扱いやすくなります:平坦な配列から、多次元配列もしくはスレッド状（threaded）の構造化データを生成します。`Model::find('threaded')` のようなメソッドで使われます。例:
:::
