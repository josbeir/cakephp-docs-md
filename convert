#!/bin/bash

# CakePHP Documentation RST to Markdown Converter (Parallel Version)
# Usage: ./convert <input_dir> <output_dir> [jobs]

set -e

# Check if pandoc is installed
if ! command -v pandoc &> /dev/null; then
    echo "Error: pandoc is required but not installed."
    echo "Please install pandoc 3.x or later."
    exit 1
fi

# Check if parallel is installed, fallback to xargs if not
USE_PARALLEL=false
if command -v parallel &> /dev/null; then
    USE_PARALLEL=true
fi

# Check arguments
if [ "$#" -lt 2 ] || [ "$#" -gt 3 ]; then
    echo "Usage: $0 <input_dir> <output_dir> [jobs]"
    echo "Example: $0 legacy/en docs/en 4"
    echo "Default jobs: number of CPU cores"
    exit 1
fi

INPUT_DIR="$1"
OUTPUT_DIR="$2"
JOBS="${3:-$(nproc)}"

# Validate input directory
if [ ! -d "$INPUT_DIR" ]; then
    echo "Error: Input directory '$INPUT_DIR' does not exist."
    exit 1
fi

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Get the absolute path of the script directory for filters
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FILTERS_DIR="$SCRIPT_DIR/pandoc_filters"

# Create filters directory if it doesn't exist
mkdir -p "$FILTERS_DIR"

# Set environment variables for substitutions
export PHPVERSION="8.4"
export MINPHPVERSION="8.1"

# Export paths for the conversion function
export INPUT_DIR_ABS="$(cd "$INPUT_DIR" && pwd)"
export OUTPUT_DIR_ABS="$(cd "$OUTPUT_DIR" && pwd)"
export FILTERS_DIR_ABS="$(cd "$FILTERS_DIR" && pwd)"
export USE_PARALLEL

echo "Converting RST documentation from $INPUT_DIR to $OUTPUT_DIR..."
echo "Using filters from: $FILTERS_DIR"

if [ "$USE_PARALLEL" = true ]; then
    echo "Running with $JOBS parallel jobs using GNU parallel..."
else
    echo "Running with $JOBS parallel jobs using xargs (install 'parallel' for better progress reporting)..."
fi

# Define the conversion function that will be exported and run in parallel
convert_file() {
    local rst_file="$1"

    # Get relative path from input directory
    local rel_path="${rst_file#$INPUT_DIR_ABS/}"

    # Create output path with .md extension
    local md_file="$OUTPUT_DIR_ABS/${rel_path%.rst}.md"

    # Create output directory structure
    mkdir -p "$(dirname "$md_file")"

    # Only show progress when not using GNU parallel (to avoid interfering with progress bar)
    if [ "$USE_PARALLEL" != true ]; then
        echo "Converting: $rel_path"
    fi

    # Create a temporary file with substitutions and include path fixes applied
    local temp_file=$(mktemp)

    # Pre-process the RST file to handle substitutions, PHP directives, and fix include paths
    # Preserve version variables as literal text for markdown-it processing
    # Note: Order matters - process minphpversion first to avoid partial matches
    sed -e "s/|minphpversion|/MINPHPVERSION_MARKER/g" \
        -e "s/|phpversion|/PHPVERSION_MARKER/g" \
        "$rst_file" | \
    python3 -c "
import re
import sys

def fix_include_paths(content):
    lines = content.split('\n')
    result_lines = []

    for line in lines:
        # Check if this is an include directive with absolute path
        include_match = re.match(r'^(\s*\.\. include::\s*)(/.*)', line)
        if include_match:
            indent = include_match.group(1)
            absolute_path = include_match.group(2)
            # Convert absolute path to relative path (remove leading slash)
            relative_path = absolute_path[1:]
            line = indent + relative_path

        result_lines.append(line)

    return '\n'.join(result_lines)

# Read from stdin
content = sys.stdin.read()
# Fix include paths
fixed_content = fix_include_paths(content)
# Output the result
sys.stdout.write(fixed_content)
" | \
    awk '
    BEGIN { namespace = ""; class = "" }

    # Capture namespace
    /^.. php:namespace::/ {
        namespace = $3
        next
    }

    # Capture class and format it
    /^.. php:class::/ {
        # Get everything after ".. php:class:: "
        class_line = $0
        gsub(/^.. php:class:: /, "", class_line)

        # Parse class name and constructor parameters
        if (match(class_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/, arr)) {
            class = arr[1]
            params = arr[2]
        } else {
            # No constructor parameters, just the class name
            class = class_line
            params = ""
        }

        if (namespace != "") {
            print ""
            print ".. raw:: html"
            print ""
            if (params != "") {
                print "   <code>class " namespace "\\<strong>" class "</strong>(" params ")</code>"
            } else {
                print "   <code>class " namespace "\\<strong>" class "</strong></code>"
            }
            print ""
        } else {
            print ""
            print ".. raw:: html"
            print ""
            if (params != "") {
                print "   <code>class <strong>" class "</strong>(" params ")</code>"
            } else {
                print "   <code>class <strong>" class "</strong></code>"
            }
            print ""
        }
        next
    }

    # Handle method directives
    /^.. php:method::/ {
        # Get everything after ".. php:method:: "
        method_line = $0
        gsub(/^.. php:method:: /, "", method_line)

        # Parse method name and parameters
        if (match(method_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*)\)\s*$/, arr)) {
            method_name = arr[1]
            params = arr[2]
        } else if (match(method_line, /^([a-zA-Z_][a-zA-Z0-9_]*)\s*$/, arr)) {
            method_name = arr[1]
            params = ""
        } else {
            # Fallback - treat the whole thing as method name
            method_name = method_line
            params = ""
        }

        # Build full class name
        if (namespace != "" && class != "") {
            full_class = namespace "\\" class
        } else if (class != "") {
            full_class = class
        } else {
            full_class = "Class"
        }

        # Format method using raw HTML
        print ""
        print ".. raw:: html"
        print ""
        if (params != "") {
            print "   <code>method " full_class "::<strong>" method_name "</strong>(" params ")</code>"
        } else {
            print "   <code>method " full_class "::<strong>" method_name "</strong>()</code>"
        }
        print ""
        next
    }

    # Remove other PHP directives we do not handle
    /^.. php:/ { next }

    # Print all other lines
    { print }
    ' > "$temp_file"

    # Get the directory of the input file for include resolution
    local rst_dir=$(dirname "$rst_file")

    # Copy temp file to the RST directory for include resolution
    local temp_in_rst_dir="$rst_dir/$(basename "$temp_file").rst"
    cp "$temp_file" "$temp_in_rst_dir"

    # Get absolute path for output
    local md_file_abs="$(cd "$(dirname "$md_file")" && pwd)/$(basename "$md_file")"

    # Set destination context and folder for the Lua filter (use absolute paths)
    local DESTINATION_CONTEXT="$md_file_abs"
    local DESTINATION_FOLDER="$OUTPUT_DIR_ABS"
    local SOURCE_FOLDER="$INPUT_DIR_ABS"
    local CURRENT_SOURCE_FILE="$rst_file"

    # Change to RST directory and run pandoc for proper include resolution
    (cd "$rst_dir" && \
    DESTINATION_CONTEXT="$DESTINATION_CONTEXT" \
    DESTINATION_FOLDER="$DESTINATION_FOLDER" \
    SOURCE_FOLDER="$SOURCE_FOLDER" \
    CURRENT_SOURCE_FILE="$CURRENT_SOURCE_FILE" \
    pandoc \
        --from=rst \
        --to=gfm \
        --wrap=preserve \
        --lua-filter="$FILTERS_DIR_ABS/meta.lua" \
        --lua-filter="$FILTERS_DIR_ABS/doc_links.lua" \
        --lua-filter="$FILTERS_DIR_ABS/ref.lua" \
        --lua-filter="$FILTERS_DIR_ABS/php_domain.lua" \
        --lua-filter="$FILTERS_DIR_ABS/fqdn_cleanup.lua" \
        --lua-filter="$FILTERS_DIR_ABS/containers.lua" \
        --lua-filter="$FILTERS_DIR_ABS/versionadded.lua" \
        --lua-filter="$FILTERS_DIR_ABS/language.lua" \
        --lua-filter="$FILTERS_DIR_ABS/images.lua" \
        --lua-filter="$FILTERS_DIR_ABS/toctree.lua" \
        --lua-filter="$FILTERS_DIR_ABS/table_cleanup.lua" \
        --lua-filter="$FILTERS_DIR_ABS/anchors.lua" \
        --lua-filter="$FILTERS_DIR_ABS/codeblocks.lua" \
        --output="$md_file_abs" \
        "$(basename "$temp_in_rst_dir")")

    # Post-process the markdown file to restore version variables
    sed -i -e "s/MINPHPVERSION_MARKER/|minphpversion|/g" \
           -e "s/PHPVERSION_MARKER/|phpversion|/g" \
           "$md_file_abs"

    # Clean up temp file in RST directory
    rm -f "$temp_in_rst_dir"

    # Clean up temp file
    rm "$temp_file"
}

# Export the function so it can be used by parallel processes
export -f convert_file

# Find all .rst files and process them in parallel
if [ "$USE_PARALLEL" = true ]; then
    # Check if we're in an interactive terminal for progress display
    if [ -t 1 ] && [ -z "$CI" ]; then
        # Interactive terminal - show progress bar
        find "$INPUT_DIR" -name "*.rst" -type f | \
            parallel --progress --bar -j "$JOBS" convert_file {}
    else
        # Non-interactive (CI/pipe) - silent mode with job count only
        TOTAL_FILES=$(find "$INPUT_DIR" -name "*.rst" -type f | wc -l)
        echo "Processing $TOTAL_FILES files with $JOBS parallel jobs..."
        find "$INPUT_DIR" -name "*.rst" -type f | \
            parallel --silent -j "$JOBS" convert_file {}
    fi
else
    # Fallback to xargs for systems without GNU parallel
    find "$INPUT_DIR" -name "*.rst" -type f -print0 | \
        xargs -0 -P "$JOBS" -I {} bash -c 'convert_file "$@"' _ {}
fi

echo "Conversion completed!"
echo "Converted files are in: $OUTPUT_DIR"